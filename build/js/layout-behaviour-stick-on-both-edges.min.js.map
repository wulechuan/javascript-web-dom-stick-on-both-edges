{"version":3,"sources":["layout-behaviour-stick-on-both-edges.js"],"names":["factory","generateAUniqueTokenUnder","tokenHost","prefix","__doGenerate","Date","now","Math","random","slice","replace","token","mergeBIntoA","a","b","key","vB","undefined","Array","isArray","prototype","push","apply","domAIsChildOfB","Node","isChild","document","documentElement","parentNode","StickOnBothEdges","nameOfClass","jQueryThrottle","_init","thisInstance","initOptions","config","_createBoundFunctions","renewState","call","shouldEnableOnInit","enableOrDisable","reasonForEnablingOrDisabling","reason","options","enable","updateLayout","boundFunctions","_privateDataOf","window","addEventListener","listenToScrollEvent","listenToResizeEvent","privatePropertiesHost","__pToken","doIntervalOfRenewingState","_doIntervalOfRenewingState","bind","doIntervalOfLayoutUpdate","_doIntervalOfLayoutUpdate","doUpdateLayout","_doUpdateLayout","throttleWrappedAction","throttleTimeForScrollAndResizeListeners","isEnabled","this","state","currentLayout","layoutStates","layouts","isFreeLayout","isPinnedToWindowTop","isPinnerToParentBottom","RangeError","logNameOfClass","currentLayoutIs","layoutNameToCheck","toLowerCase","pName","pValue","moduleOptions","hasOwnProperty","parseInt","isNaN","_configAnEvent","eventName","eventsHost","events","input","_dispatchAnEvent","shouldWarnIfNotHandled","console","warn","reasonForEnabling","disable","reasonForDisabling","shouldDestroyAfterDisabled","destroy","shouldEnable","_onEnablingOrDisabling","logString1","newState","isForcedToRenew","requestLayoutUpdate","willEnable","shouldCancelDisabling","_onEnabledOrDisabled","isNowEnabled","publicState","clearIntervalOfRenewingState","clearIntervalOfLayoutUpdate","_destroyOneInstanceAfterLayoutRestoredToFree","elements","removeEventListener","root","style","height","hangingBlock","top","______soloCssClassTo","startIntervalOfRenewingState","_startOrClearIntervalOfRenewingState","shouldStart","privateData","privateState","logString2","pNameForIndex","currentIndex","hasActiveInterval","info","setInterval","intervalTimeForRenewingState","clearInterval","NaN","startIntervalOfLayoutUpdate","_startOrClearIntervalOfLayoutUpdate","intervalTimeForUpdatingLayout","renewStateAndThenUpdate","setContentTopToWindowTopInHangingLayouts","contentTopToWindowTopInHangingLayouts","setContentBottomToLowerBoundary","contentBottomToLowerBoundaryInHangingLayouts","setLowerBoundaryRefElement","lowerBoundaryRefElement","setUsedEdgeOfLowerBoundaryRefElement","shouldUseBottomEdgeOfLowerBoundaryRefElement","_renewContentHeight","_renewContentTopToRootTopInFreeLayout","_renewContentTopToPageTopInFreeLayout","newExtraSpace","isForcedToUpdate","parseFloat","newElement","rootElement","newElementIsValid","edgeUsageHasBeenDecidedHereInsideThisFunction","lowerBoundaryRef","blockHeight","offsetHeight","offsetTop","isForcedToRenewWithoutWaitingForLayoutToSwitch","functionForSwitchingToCorrectLayout","shouldDoRenew","forcedImmediateSwitchingWasSkipped","methodForSwitchingToCurrentLayout","____switchLayoutToFree","__doRenewContentTopToPageTopInFreeLayout","contentClientRect","getBoundingClientRect","width","contentTopToPageTopInFreeLayout","scrollY","newStateOrFunctionToGenerateNewStateOrABoolean","statesQueue","updatingStatesQueue","length","stateToUpdate","__processOneQueuedStateForAnUpdateOfLayoutInQueue","shift","___detectChangesBetweenStates","_mergeNewStateIntoModuleCurrentState","state1","state2","____detectChangesOnAllPropertiesAndRemoveThoseWontChangeFromState2","____processState2AccordingToPreservedProperties","Object","keys","forEach","_____detectChangeForAProperty","somethingChanged","object1","object2","changed","v1","v2","pName1","logString3","willEnableHanging","indentAlignsToLogNameOfClass","__evaluateHangingBoundries","hangingTopOffset","topBoundaryToPageTop","boundriesDistance","hangingLowerBoundaryToPageTop","requiredRoomInY","availableRoomInY","hangingLowerBoundaryToWindowTop","blockRootHeightWhenPinned","thereIsNoEnoughRoomForThisBlockToHang","innerHeight","____switchLayoutToContentPinningAboveLowerBoundary","clientTop","contentTopToRootTopInFreeLayout","____switchLayoutToContentHangingToWindowTop","refElementClientRect","refElement","refNewYToWindowTop","refNewYToPageTop","isForcedByAForcedRenew","layoutBeforeSwitchingWasExactlyFreeLayout","switchingWasSkipped","_____commonActionsWhenSwitchingLayout","pNameOfLayoutMark","pNameOfCssClass","rootElHeight","contentElTop","shouldAlwaysRenewFreeLayoutInfo","blockContentTopWhenPinned","contentElNewTop","logInfo","logStringWhenActuallySwitching","shouldDebug","______soloLayoutStateTo","propertyKeyOfLayoutState","propertyKeyOfCssClassToApply","hangingBlockClassList","classList","cssClassNameOptions","cssClassName","add","remove","rawConsole","loggingLevel","rawMethod","constructionOptions","layoutFreeTemporary","layoutFree","layoutPinToWindowTop","layoutPinToParentBottom","Error","hangingBlockElement","shouldRenewFreeLayoutInfoNextTimeEnteringFreeLayout","intervalIDForRenewingState","intervalIDForUpdatingLayout","jQuery","throttle","Cowboy","module","exports"],"mappings":"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","file":"layout-behaviour-stick-on-both-edges.min.js","sourcesContent":["\n\n/*** Class: LayoutBehaviour:StickOnBothEdges\n */\n(function (factory) { var nameOfClass = 'StickOnBothEdges';\n\tvar StickOnBothEdges = factory(\n\t\tnameOfClass,\n\t\tgenerateAUniqueTokenUnder,\n\t\tmergeBIntoA,\n        domAIsChildOfB,\n\t\t(window.jQuery && window.jQuery.throttle) || (window.Cowboy && window.Cowboy.throttle)\n\t);\n\n\tif (window.module && window.module.exports) {\n\t\tmodule.exports = StickOnBothEdges\n\t} else {\n\t\twindow[nameOfClass] = StickOnBothEdges;\n\t}\n\n\n\n\tfunction generateAUniqueTokenUnder(tokenHost, prefix) {\n\t\tfunction __doGenerate() {\n\t\t\treturn prefix + Date.now() + '-' + ((Math.random() * 1000000) + '').slice(0, 6);\n\t\t}\n\n\t\tprefix = typeof prefix === 'string' ? prefix : '';\n\t\tprefix = prefix.replace(/\\-+$/, '') + '-';\n\t\tvar token = __doGenerate();\n\t\twhile (tokenHost[token]) {\n\t\t\ttoken = __doGenerate();\n\t\t}\n\n\t\treturn token;\n\t}\n\n\tfunction mergeBIntoA(a, b) {\n\t\tif (!a || typeof a !== 'object') return null;\n\t\tif (!b || typeof b !== 'object') return a;\n\n\t\tfor (var key in b) {\n\t\t\tvar vB = b[key];\n\t\t\tif (vB === undefined) continue; // null value is acceptable\n\t\t\tif (Array.isArray(vB)) {\n\t\t\t\tif (Array.isArray(a[key])) {\n\t\t\t\t\tArray.prototype.push.apply(a[key], vB); // keep reference to original a[key]\n\t\t\t\t} else {\n\t\t\t\t\ta[key] = vB;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ta[key] = vB;\n\t\t\t}\n\t\t}\n\n\t\treturn a;\n\t}\n\n    function domAIsChildOfB(a, b) {\n        if (!(a instanceof Node && b instanceof Node)) return false;\n\n        var isChild = false;\n        while (a !== b && a !== document.documentElement) {\n            a = a.parentNode;\n            if (a === b) {\n                isChild = true;\n            }\n        }\n\n        return isChild;\n    }\n})(function factory(nameOfClass, generateAUniqueTokenUnder, mergeBIntoA, domAIsChildOfB, jQueryThrottle) {\n\t'use strict';\n\n\t// private and also static properties (shared across instances)\n\tvar logNameOfClass = '{'+nameOfClass+'} ==>',\n\t\tindentAlignsToLogNameOfClass = logNameOfClass.replace(/\\S/g, ' ')\n\t;\n\n\n\tvar rawConsole = window.console;\n\tvar console = {};\n\n\t['log', 'info', 'warn', 'debug', 'trace', 'error'].forEach(function (loggingLevel) {\n\t\tvar rawMethod = rawConsole[loggingLevel];\n\t\tif (typeof rawMethod === 'function') {\n\t\t\tconsole[loggingLevel] = rawMethod.bind(rawConsole, logNameOfClass);\n\t\t}\n\t});\n\n\t// This is an object shared by for all instances\n\t// whoever are constructed via the class/function defined in this closure.\n\t// Each and every instance has its own unique __pToken to access its own private data,\n\t// without knowing how to access that for other instances.\n\tvar privatePropertiesHost = {};\n\n\t// Now, define the class/function and return it by factory function\n\treturn function StickOnBothEdges(constructionOptions) {\n\t\t'use strict';\n\n\t\t// Use \"thisInstance\" intead of \"this\" is for better compression ratio of js files.\n\t\t// Should use this trig whenever the appearances of \"this\" is more than 5 times.\n\t\tvar thisInstance = this;\n\t\t// console.log(thisInstance);\n\n\t\t// Public this object just for callback functions, which often defined somewhere outside this file, to utilize.\n\t\tthisInstance.console = console;\n\n\t\t// This is the public options object of an instance.\n\t\tthisInstance.options = {\n\t\t\t// The deeply nested content of the block might NOT be ready\n\t\t\t// at the time this controller is constructed.\n\t\t\t// This could be especially true when the block is an Ad.\n\t\t\t// So we might choose not to enable the behaviour of this controller instance.\n\t\t\t// Instead, we may choose to invoke:\n\t\t\t//\t<instanceObject>.enable('My ad is ready')\n\t\t\t// explicitly, to enable it at proper anytime.\n\t\t\tshouldEnableOnInit: false,\n\n\t\t\t// if there are some other coupled blocks might effect the top of this block\n\t\t\tshouldAlwaysRenewFreeLayoutInfo: true, // everytime it enters the free layout mode\n\n\t\t\tcssClassName: {\n\t\t\t\tlayoutFreeTemporary: 'js-stick-on-both-edges-layout-temporarily-free',\n\t\t\t\tlayoutFree: 'js-stick-on-both-edges-layout-free',\n\t\t\t\tlayoutPinToWindowTop: 'js-stick-on-both-edges-layout-hang-to-window-top',\n\t\t\t\tlayoutPinToParentBottom: 'js-stick-on-both-edges-layout-pin-to-lower-boundary',\n\t\t\t},\n\n\t\t\tintervalTimeForRenewingState: 500,\n\t\t\tintervalTimeForUpdatingLayout: 40,\n\t\t\tthrottleTimeForScrollAndResizeListeners: 16\n\t\t};\n\n\n\t\t// This is the public state object of an instance.\n\t\t// everything inside this object are constantly be checked and compared with that of new states,\n\t\t// Do NOT comment out any property that will be used later,\n\t\t// because we are using Object.keys() to determine what to check.\n\t\tthisInstance.state = {\n\t\t\tshouldEnable: false, // the global switch\n\n\n\t\t\t// important measurements and involved switches\n\t\t\tblockHeight: NaN,\n\t\t\tcontentTopToPageTopInFreeLayout: NaN,\n\t\t\tcontentTopToRootTopInFreeLayout: 0,\n\t\t\tcontentTopToWindowTopInHangingLayouts: 0,\n\t\t\tcontentBottomToLowerBoundaryInHangingLayouts: 15,\n\n\t\t\tlowerBoundaryRefElement: null, // exactly the same as this.elements.lowerBoundaryRef\n\t\t\tshouldUseBottomEdgeOfLowerBoundaryRefElement: true,\n\t\t\thangingLowerBoundaryToPageTop: NaN\n\n\n\n\t\t\t// We might lose the margins caused by inner content whenver the content is pinned,\n\t\t\t// no matter it's pinned above or below.\n\t\t\t// So these values are something we need to remember and make compensation for.\n\t\t\t// But situation could be complicated.\n\t\t\t// The root block might has its own margins, as well as the block below has ITS own margins.\n\t\t\t// If a margin value of the inner content is greater than involved margin values from the root and the block below\n\t\t\t// then a compensation is needed, otherwise not.\n\t\t\t// I actually deprecated this value for simplify things.\n\t\t\t// innerContentKnownMarginTop: 0, // also used for calculating required room in y\n\t\t\t// innerContentKnownMarginBottom: 0 // also used for calculating required room in y\n\t\t};\n\n\n\n\n\n\n\t\tconstructionOptions = constructionOptions || {};\n\n\t\tif (!(constructionOptions.rootElement instanceof Node)) {\n\t\t\tthrow new Error('Invalid root element.');\n\t\t}\n\n\t\tif (!(constructionOptions.hangingBlockElement instanceof Node)) {\n\t\t\tthrow new Error('Invalid hangingBlock element.');\n\t\t}\n\n\t\tthisInstance.elements = {\n\t\t\troot: constructionOptions.rootElement, // as the wrapper and the placeholder for the hangingBlock element\n\t\t\thangingBlock: constructionOptions.hangingBlockElement,\n\t\t\tlowerBoundaryRef: null\n\t\t};\n\n\n\n\n\n\t\tvar privateData = {\n\t\t\tstate: {\n\t\t\t\t// layout status marks\n\t\t\t\tlayouts: {\n\t\t\t\t\tisFreeLayout: true,\n\t\t\t\t\tisPinnedToWindowTop: false,\n\t\t\t\t\tisPinnerToParentBottom: false,\n\t\t\t\t},\n\n\n\t\t\t\t// the global switch\n\t\t\t\tisEnabled: false,\n\n\n\t\t\t\t// helpers\n\t\t\t\tsomethingChanged: false,\n\t\t\t\thangingLowerBoundaryToWindowTop: NaN,\n\t\t\t\tshouldRenewFreeLayoutInfoNextTimeEnteringFreeLayout: false,\n\n\n\t\t\t\t// misc\n\t\t\t\tintervalIDForRenewingState: NaN,\n\t\t\t\tintervalIDForUpdatingLayout: NaN\n\t\t\t},\n\n\n\t\t\t// functions\n\t\t\tevents: {},\n\t\t\tboundFunctions: {},\n\n\n\t\t\t// the queued tasks (states actually), btw, at present no more than one task is allowed\n\t\t\tupdatingStatesQueue: [],\n\t\t};\n\n\t\tthisInstance.__pToken = generateAUniqueTokenUnder(privatePropertiesHost, nameOfClass);\n\t\tprivatePropertiesHost[thisInstance.__pToken] = privateData;\n\n\n\n\n\t\t// events\n\t\t// they are private, so must be updated via this.config method\n\t\t// privateData.events.onEnabling;\n\t\t// privateData.events.onEnabled;\n\n\t\t// privateData.events.onDisabling;\n\t\t// privateData.events.onDisabled;\n\n\t\t// privateData.events.onDestroying;\n\t\t// privateData.events.onDestroyed;\n\n\t\t// privateData.events.onUpdatingLayout; // not implemented yet\n\t\t// privateData.events.onUpdatedLayout; // not implemented yet\n\n\t\t// privateData.events.onReturningToFreeLayout;\n\t\t// privateData.events.onReturnedToFreeLayout;\n\n\t\t// privateData.events.onIntervalBegin;\n\t\t// privateData.events.onIntervalEnd;\n\n\n\n\t\t// public methods\n\t\tthisInstance.config = config;\n\n\t\tthisInstance.isEnabled = isEnabled;\n\t\tthisInstance.currentLayout = currentLayout;\n\t\tthisInstance.currentLayoutIs = currentLayoutIs;\n\n\t\tthisInstance.enableOrDisable = enableOrDisable;\n\t\tthisInstance.enable = enable;\n\t\tthisInstance.disable = disable;\n\n\t\tthisInstance.destroy = destroy;\n\n\t\tthisInstance.renewState = renewState;\n\t\tthisInstance.renewStateAndThenUpdate = renewStateAndThenUpdate;\n\t\t// thisInstance.setContentTopToWindowTopInHangingLayouts = setContentTopToWindowTopInHangingLayouts;\n\t\t// thisInstance.setContentBottomToLowerBoundary = setContentBottomToLowerBoundary;\n\t\t// thisInstance.setLowerBoundaryRefElement = setLowerBoundaryRefElement;\n\t\t// thisInstance.setUsedEdgeOfLowerBoundaryRefElement = setUsedEdgeOfLowerBoundaryRefElement;\n\n\n\t\t// a very traditional way to safely update related info\n\t\tthisInstance.startIntervalOfRenewingState = startIntervalOfRenewingState;\n\t\tthisInstance.clearIntervalOfRenewingState = clearIntervalOfRenewingState;\n\t\tthisInstance.startIntervalOfLayoutUpdate = startIntervalOfLayoutUpdate;\n\t\tthisInstance.clearIntervalOfLayoutUpdate = clearIntervalOfLayoutUpdate;\n\n\t\tthisInstance.requestLayoutUpdate = requestLayoutUpdate;\n\t\tthisInstance.updateLayout = updateLayout;\n\n\n\n\n\t\t// init\n\t\t_init(thisInstance, constructionOptions);\n\t\t// console.info('Initialized!', thisInstance);\n\t};\n\n\n\n\n\n\tfunction _init(thisInstance, initOptions) {\n\t\tthisInstance.config(initOptions);\n\n\n\n\t\t_createBoundFunctions(thisInstance);\n\n\n\n\t\t// Store initial states\n\t\trenewState.call(thisInstance, initOptions, true);\n\n\t\tif (typeof initOptions.shouldEnableOnInit === 'boolean') {\n\t\t\tenableOrDisable.call(thisInstance,\n\t\t\t\tinitOptions.shouldEnableOnInit,\n\t\t\t\tinitOptions.reasonForEnablingOrDisabling || initOptions.reason || 'User desired on initialization.'\n\t\t\t);\n\t\t} else if (thisInstance.options.shouldEnableOnInit) {\n\t\t\tenable.call(thisInstance, 'Forced to enabled on initialization.');\n\t\t}\n\n\t\tupdateLayout.call(thisInstance);\n\n\n\n\n\t\t// Third, also update layout whenever user is scrolling or resizing window\n\t\tvar boundFunctions = _privateDataOf(thisInstance).boundFunctions;\n\t\twindow.addEventListener('scroll', boundFunctions.listenToScrollEvent);\n\t\twindow.addEventListener('resize', boundFunctions.listenToResizeEvent);\n\t}\n\n\tfunction _privateDataOf(thisInstance) {\n\t\treturn privatePropertiesHost[thisInstance.__pToken];\n\t}\n\n\tfunction _createBoundFunctions(thisInstance) {\n\t\tvar boundFunctions = _privateDataOf(thisInstance).boundFunctions;\n\n\t\tboundFunctions.doIntervalOfRenewingState =\n\t\t\t_doIntervalOfRenewingState.bind(null, thisInstance);\n\n\t\tboundFunctions.doIntervalOfLayoutUpdate =\n\t\t\t_doIntervalOfLayoutUpdate.bind(null, thisInstance);\n\n\n\n\t\t// Even without a task in queue, we still need to update layout constantly.\n\t\t// For example when user is scrolliing the page, nothing about the important measurements changed\n\t\t// but obviously the _doUpdateLayout should be invoked still.\n\t\tboundFunctions.doUpdateLayout = (function (/*event*/) {\n\t\t\t_doUpdateLayout(thisInstance);\n\t\t}).bind(thisInstance);\n\n\n\n\n\t\tvar throttleWrappedAction = jQueryThrottle(\n\t\t\tthisInstance.options.throttleTimeForScrollAndResizeListeners,\n\t\t\tboundFunctions.doUpdateLayout\n\t\t);\n\n\t\tboundFunctions.listenToScrollEvent = throttleWrappedAction;\n\t\tboundFunctions.listenToResizeEvent = throttleWrappedAction;\n\t}\n\n\tfunction isEnabled() {\n\t\treturn _privateDataOf(this).state.isEnabled;\n\t}\n\n\tfunction currentLayout() {\n\t\tvar layoutStates = _privateDataOf(this).state.layouts;\n\n\t\tif (layoutStates.isFreeLayout) return 'free layout';\n\t\tif (layoutStates.isPinnedToWindowTop) return 'pinned to top';\n\t\tif (layoutStates.isPinnerToParentBottom) return 'following lower boundary';\n\n\t\tthrow RangeError(logNameOfClass, 'Fatal: None of the three states are active.');\n\t}\n\n\tfunction currentLayoutIs(layoutNameToCheck) {\n\t\tvar layoutStates = _privateDataOf(this).state.layouts;\n\n\t\tif (!layoutNameToCheck || typeof layoutNameToCheck !== 'string') {\n\t\t\treturn false;\n\t\t}\n\n\n\t\tvar normalizedString = layoutNameToCheck\n\t\t\t.toLowerCase()\n\t\t\t.replace(/\\s*[\\s\\-]\\s*/g, '-')\n\t\t\t.replace(/^\\s+/, '')\n\t\t\t.replace(/\\s+$/, '')\n\t\t\t;\n\n\t\tswitch (normalizedString) {\n\t\tcase 'free':\n\t\tcase 'freelayout':\n\t\tcase 'default':\n\t\t\treturn layoutStates.isFreeLayout;\n\n\t\tcase 'top':\n\t\tcase 'hanging':\n\t\tcase 'pinned-to-top':\n\t\t\treturn layoutStates.isPinnedToWindowTop;\n\n\t\tcase 'following':\n\t\tcase 'bottom':\n\t\tcase 'following-lower-boundary':\n\t\tcase 'pinned-to-bottom':\n\t\t\treturn layoutStates.isPinnerToParentBottom;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction config(options) {\n\t\tvar thisInstance = this,\n\t\t\tmoduleOptions = thisInstance.options,\n\t\t\tpName,\n\t\t\tpValue\n\t\t\t;\n\n\n\n\t\tpName = 'intervalTimeForRenewingState';\n\t\tif (options.hasOwnProperty(pName)) {\n\t\t\tpValue = parseInt(options[pName]);\n\t\t\tif (!isNaN(pValue) && pValue > 20) { // acceptable threshold\n\t\t\t\tmoduleOptions[pName] = pValue;\n\t\t\t}\n\t\t}\n\n\n\n\t\tpName = 'intervalTimeForUpdatingLayout';\n\t\tif (options.hasOwnProperty(pName)) {\n\t\t\tpValue = parseInt(options[pName]);\n\t\t\tif (!isNaN(pValue) && pValue > 20) { // acceptable threshold\n\t\t\t\tmoduleOptions[pName] = pValue;\n\t\t\t}\n\t\t}\n\n\n\n\t\t_configAnEvent(thisInstance, 'onEnabling', options);\n\t\t_configAnEvent(thisInstance, 'onEnabled', options);\n\n\t\t_configAnEvent(thisInstance, 'onDisabling', options);\n\t\t_configAnEvent(thisInstance, 'onDisabled', options);\n\n\t\t_configAnEvent(thisInstance, 'onDestroying', options);\n\t\t_configAnEvent(thisInstance, 'onDestroyed', options);\n\n\t\t_configAnEvent(thisInstance, 'onReturningToFreeLayout', options);\n\t\t_configAnEvent(thisInstance, 'onReturnedToFreeLayout', options);\n\n\t\t// _configAnEvent(thisInstance, 'onUpdatingLayout', options);\n\t\t// _configAnEvent(thisInstance, 'onUpdatedLayout', options);\n\n\t\t_configAnEvent(thisInstance, 'onIntervalBegin', options);\n\t\t_configAnEvent(thisInstance, 'onIntervalEnd', options);\n\t}\n\n\tfunction _configAnEvent(thisInstance, eventName, options) {\n\t\tvar eventsHost = _privateDataOf(thisInstance).events,\n\t\t\tinput = options[eventName]\n\t\t;\n\n\t\tif (typeof input === 'function' || input === undefined) {\n\t\t\teventsHost[eventName] = input;\n\t\t}\n\t}\n\n\tfunction _dispatchAnEvent(thisInstance, eventName, shouldWarnIfNotHandled) {\n\t\tvar eventsHost = _privateDataOf(thisInstance).events;\n\n\t\tif (typeof eventsHost[eventName] !== 'function') {\n\t\t\tif (shouldWarnIfNotHandled) {\n\t\t\t\tconsole.warn('The \"'+eventName+'\" is NOT handled.');\n\t\t\t}\n\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn eventsHost[eventName].call(thisInstance, thisInstance.state);\n\t\t}\n\t}\n\n\n\n\n\n\n\tfunction enable(reasonForEnabling) {\n\t\tenableOrDisable.call(this, true, reasonForEnabling);\n\t}\n\n\tfunction disable(reasonForDisabling, shouldDestroyAfterDisabled) {\n\t\tenableOrDisable.call(this, false, reasonForDisabling, shouldDestroyAfterDisabled);\n\t}\n\n\tfunction destroy(reason) {\n\t\tdisable.call(this, reason, true);\n\t}\n\n\tfunction enableOrDisable(shouldEnable, reason, shouldDestroyAfterDisabled) {\n\t\tif (typeof shouldEnable === 'undefined') return;\n\t\tshouldEnable = !!shouldEnable;\n\n\n\t\tvar shouldCancel = _onEnablingOrDisabling(this,\n\t\t\tshouldEnable,\n\t\t\tshouldDestroyAfterDisabled\n\t\t);\n\n\t\tif (shouldCancel) {\n\t\t\tvar logString1 = shouldEnable ? 'Enabling' : shouldDestroyAfterDisabled ? 'DESTORYING' : 'DISABLING';\n\t\t\tconsole.warn(logString1, 'request was cancelled.');\n\t\t\treturn;\n\t\t}\n\n\n\n\t\tvar newState = {};\n\t\tnewState.shouldEnable = !!shouldEnable;\n\t\t\n\t\t// must contains a reason property,\n\t\t// for overwriting that of previously queued states.\n\t\tnewState.reason = (reason && typeof reason === 'string') ? reason : '<unkown>';\n\n\t\tif (!shouldEnable && shouldDestroyAfterDisabled) {\n\t\t\tnewState.isForcedToRenew = true;\n\t\t\tnewState.shouldDestroyAfterDisabled = true;\n\t\t}\n\n\t\trequestLayoutUpdate.call(this, newState);\n\n\n\t\tupdateLayout.call(this);\n\t}\n\n\tfunction _onEnablingOrDisabling(thisInstance, willEnable, shouldDestroyAfterDisabled) {\n\t\t// return value: true means shouldCancel <boolean>\n\t\t// Note that event handlers also return true means shouldCancel <boolean>\n\n\n\t\tif (willEnable) {\n\t\t\treturn _dispatchAnEvent(thisInstance, 'onEnabling');\n\t\t}\n\n\n\t\tvar shouldCancelDisabling = _dispatchAnEvent(thisInstance, 'onDisabling');\n\n\t\tif (shouldCancelDisabling) {\n\t\t\tif (!shouldDestroyAfterDisabled) {\n\t\t\t\treturn shouldCancelDisabling;\n\t\t\t} else {\n\t\t\t\tconsole.warn('Destroying request will be cancelled by onDisabling handler.');\n\t\t\t}\n\t\t}\n\n\n\t\treturn _dispatchAnEvent(thisInstance, 'onDestroying');\n\t}\n\n\tfunction _onEnabledOrDisabled(thisInstance, isNowEnabled) {\n\t\tvar publicState = thisInstance.state;\n\n\t\t// console.log('\\n===== _onEnabledOrDisabled', isNowEnabled, '\\n=====');\n\t\t_privateDataOf(thisInstance).state.isEnabled = isNowEnabled;\n\n\t\tif (isNowEnabled) {\n\t\t\tdelete publicState.shouldDestroyAfterDisabled;\n\n\t\t\t// The invocation below might cause an infinite loop!\n\t\t\t// Enhancements are needed!\n\t\t\t_dispatchAnEvent(thisInstance, 'onEnabled');\n\t\t} else {\n\t\t\t_dispatchAnEvent(thisInstance, 'onDisabled');\n\n\t\t\tthisInstance.clearIntervalOfRenewingState();\n\t\t\tthisInstance.clearIntervalOfLayoutUpdate();\n\n\t\t\tif (publicState.shouldDestroyAfterDisabled) {\n\t\t\t\t_destroyOneInstanceAfterLayoutRestoredToFree(thisInstance);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _destroyOneInstanceAfterLayoutRestoredToFree(thisInstance) {\n\t\tvar elements = thisInstance.elements,\n\t\t\tboundFunctions = _privateDataOf(thisInstance).boundFunctions\n\t\t;\n\n\t\twindow.removeEventListener('scroll', boundFunctions.listenToScrollEvent);\n\t\twindow.removeEventListener('resize', boundFunctions.listenToResizeEvent);\n\n\t\telements.root.style.height = '';\n\t\telements.hangingBlock.style.top = '';\n\t\t______soloCssClassTo(thisInstance, null);\n\n\t\t_dispatchAnEvent(thisInstance, 'onDestroyed', true);\n\t}\n\n\n\n\n\tfunction startIntervalOfRenewingState() {\n\t\t_startOrClearIntervalOfRenewingState(this, true);\n\t}\n\tfunction clearIntervalOfRenewingState() {\n\t\t_startOrClearIntervalOfRenewingState(this, false);\n\t}\n\tfunction _startOrClearIntervalOfRenewingState(thisInstance, shouldStart) {\n\t\tvar privateData = _privateDataOf(thisInstance),\n\t\t\tprivateState = privateData.state,\n\t\t\tlogString1 = shouldStart ? 'Starting' : 'STOPPING',\n\t\t\tlogString2 = 'interval for renewing related info.',\n\t\t\t// logString3 =  '\\n\\t module rootElement:',\n\t\t\t// rootElement = thisInstance.elements.root,\n\t\t\tpNameForIndex = 'intervalIDForRenewingState',\n\t\t\tcurrentIndex = privateState[pNameForIndex],\n\t\t\thasActiveInterval = !isNaN(currentIndex)\n\t\t\t;\n\n\t\tif (shouldStart && !hasActiveInterval) {\n\t\t\tconsole.info(logString1, logString2\n\t\t\t\t// , logString3, rootElement\n\t\t\t);\n\t\t\tprivateState[pNameForIndex] = setInterval(\n\t\t\t\tprivateData.boundFunctions.doIntervalOfRenewingState,\n\t\t\t\tthisInstance.options.intervalTimeForRenewingState\n\t\t\t);\n\t\t} else if (!shouldStart && hasActiveInterval) {\n\t\t\tconsole.warn(logString1, logString2\n\t\t\t\t// , logString3, rootElement\n\t\t\t);\n\t\t\tclearInterval(currentIndex);\n\t\t\tprivateState[pNameForIndex] = NaN;\t\t\t\n\t\t}\n\t}\n\tfunction _doIntervalOfRenewingState(thisInstance) {\n\t\tvar shouldCancel = _dispatchAnEvent(thisInstance, 'onIntervalBegin');\n\n\t\tif (!shouldCancel) {\n\t\t\trenewState.call(thisInstance, null, true);\n\t\t}\n\n\t\t// even if this interval is cancelled, still call the onIntervalEnd event\n\t\t// need more thinking\n\t\t_dispatchAnEvent(thisInstance, 'onIntervalEnd');\n\t}\n\n\n\n\n\tfunction startIntervalOfLayoutUpdate() {\n\t\t_startOrClearIntervalOfLayoutUpdate(this, true);\n\t}\n\tfunction clearIntervalOfLayoutUpdate() {\n\t\t_startOrClearIntervalOfLayoutUpdate(this, false);\n\t}\n\tfunction _startOrClearIntervalOfLayoutUpdate(thisInstance, shouldStart) {\n\t\tvar privateData = _privateDataOf(thisInstance),\n\t\t\tprivateState = privateData.state,\n\t\t\tlogString1 = shouldStart ? 'Starting' : 'STOPPING',\n\t\t\tlogString2 = 'interval for updating layout.',\n\t\t\t// logString3 = indentAlignsToLogNameOfClass.slice(0, -15) + ' module rootElement:',\n\t\t\t// rootElement = this.elements.root,\n\t\t\tpNameForIndex = 'intervalIDForUpdatingLayout',\n\t\t\tcurrentIndex = privateState[pNameForIndex],\n\t\t\thasActiveInterval = !isNaN(currentIndex)\n\t\t\t;\n\n\t\tif (shouldStart && !hasActiveInterval) {\n\t\t\tconsole.info(logString1, logString2\n\t\t\t\t// , '\\n' + logString3, rootElement\n\t\t\t);\n\t\t\tprivateState[pNameForIndex] = setInterval(\n\t\t\t\tprivateData.boundFunctions.doIntervalOfLayoutUpdate,\n\t\t\t\tthisInstance.options.intervalTimeForUpdatingLayout\n\t\t\t);\n\t\t} else if (!shouldStart && hasActiveInterval) {\n\t\t\tconsole.warn(logString1, logString2\n\t\t\t\t// , '\\n ' + logString3, rootElement\n\t\t\t);\n\t\t\tclearInterval(currentIndex);\n\t\t\tprivateState[pNameForIndex] = NaN;\t\t\t\n\t\t}\n\t}\n\tfunction _doIntervalOfLayoutUpdate(thisInstance) {\n\t\tupdateLayout.call(thisInstance);\n\t}\n\n\n\n\n\t// renew all state but NOT the global switch, aka the this.state.shouldEnable\n\tfunction renewStateAndThenUpdate(options) {\n\t\trenewState.call(this, options, false);\n\t\tupdateLayout.call(this);\n\t}\n\n\t// renew all state but NOT the global switch, aka the this.state.shouldEnable\n\tfunction renewState(options, isForcedToRenew) {\n\t\t// actions that relies on arguments\n\t\tif (typeof options === 'object' && options) {\n\t\t\tsetContentTopToWindowTopInHangingLayouts.call(this,\n\t\t\t\toptions.contentTopToWindowTopInHangingLayouts,\n\t\t\t\tisForcedToRenew\n\t\t\t);\n\n\t\t\tsetContentBottomToLowerBoundary.call(this,\n\t\t\t\toptions.contentBottomToLowerBoundaryInHangingLayouts,\n\t\t\t\tisForcedToRenew\n\t\t\t);\n\n\t\t\tvar edgeUsageHasBeenDecidedViaNewRefElement = setLowerBoundaryRefElement.call(this,\n\t\t\t\toptions.lowerBoundaryRefElement,\n\t\t\t\tisForcedToRenew\n\t\t\t);\n\n\t\t\tif (!edgeUsageHasBeenDecidedViaNewRefElement) {\n\t\t\t\tsetUsedEdgeOfLowerBoundaryRefElement.call(this,\n\t\t\t\t\toptions.shouldUseBottomEdgeOfLowerBoundaryRefElement,\n\t\t\t\t\tisForcedToRenew\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\n\n\t\t// actions that need no arguments\n\t\t_renewContentHeight.call(this, isForcedToRenew);\n\t\t_renewContentTopToRootTopInFreeLayout.call(this, isForcedToRenew);\n\t\t_renewContentTopToPageTopInFreeLayout.call(this, isForcedToRenew);\n\t}\n\n\n\n\tfunction setContentTopToWindowTopInHangingLayouts(newExtraSpace, isForcedToRenew) {\n\t\tvar newState = {};\n\n\t\tif (isForcedToRenew) newState.isForcedToUpdate = true;\n\n\t\tnewExtraSpace = parseFloat(newExtraSpace);\n\t\tif (!isNaN(newExtraSpace)) {\n\t\t\tnewState.contentTopToWindowTopInHangingLayouts = newExtraSpace;\n\t\t}\n\n\t\trequestLayoutUpdate.call(this, newState);\n\t}\n\n\tfunction setContentBottomToLowerBoundary(newExtraSpace, isForcedToRenew) {\n\t\tvar newState = {};\n\n\t\tif (isForcedToRenew) newState.isForcedToUpdate = true;\n\n\t\tnewExtraSpace = parseFloat(newExtraSpace);\n\t\tif (!isNaN(newExtraSpace)) {\n\t\t\tnewState.contentBottomToLowerBoundaryInHangingLayouts = newExtraSpace;\n\t\t}\n\n\t\trequestLayoutUpdate.call(this, newState);\n\t}\n\n    function setLowerBoundaryRefElement(newElement, isForcedToRenew) {\n\t\tvar newState = {};\n\n\t\tif (isForcedToRenew) newState.isForcedToUpdate = true;\n\n        var elements = this.elements,\n            rootElement = elements.root,\n            pName = 'lowerBoundaryRef',\n            newElementIsValid = true,\n            logString1 = 'The lower boundary ref element',\n            logString2 = 'This doesn\\'t make any sense. Ref element NOT renewed.'\n            ;\n\n        if (newElement !== null) { // null value is acceptable for removing lower boundary ref element\n            if (!(newElement instanceof Node)) {\n                newElementIsValid = false;\n            } else if (domAIsChildOfB(newElement, rootElement)) {\n                newElementIsValid = false;\n                console.warn(logString1, 'is a descendant of the root element.', logString2);\n            } else if (newElement === rootElement) {\n                newElementIsValid = false;\n                console.warn(logString1, 'is the same dom as the root element.', logString2);                \n            }\n        }\n\n\n\t\tvar edgeUsageHasBeenDecidedHereInsideThisFunction = false;\n\n        if (newElementIsValid && elements[pName] !== newElement) {\n            elements[pName] = newElement;\n\t\t\tnewState[pName+'Element'] = newElement;\n\n            if (domAIsChildOfB(rootElement, newElement)) {\n\t\t\t\tsetUsedEdgeOfLowerBoundaryRefElement.call(this, true, isForcedToRenew);\n\n\t\t\t\t// Here the false value means\n\t\t\t\t// the \"shouldUseBottomEdgeOfLowerBoundaryRefElement\"\n\t\t\t\t// has been decided here (the above line),\n\t\t\t\t// so the setUsedEdgeOfLowerBoundaryRefElement()\n\t\t\t\t// should NOT be invoked inside the renewState() again,\n\t\t\t\t// thus the input argument for \"shouldUseBottomEdgeOfLowerBoundaryRefElement\"\n\t\t\t\t// will be ignored if any.\n                edgeUsageHasBeenDecidedHereInsideThisFunction = true;\n            }\n\n\t\t\trequestLayoutUpdate.call(this, newState);\n        }\n\n\t\treturn edgeUsageHasBeenDecidedHereInsideThisFunction;\n    }\n\n\tfunction setUsedEdgeOfLowerBoundaryRefElement(shouldUseBottomEdgeOfLowerBoundaryRefElement, isForcedToRenew) {\n\t\tvar thisInstance = this,\n\t\t\telements = thisInstance.elements\n\t\t;\n\n\t\tif (typeof shouldUseBottomEdgeOfLowerBoundaryRefElement !== 'boolean') {\n\t\t\treturn;\n\t\t}\n\n\t\tif (domAIsChildOfB(elements.root, elements.lowerBoundaryRef)) {\n\t\t\t// Should always use 'bottom'\n\t\t\treturn;\n\t\t}\n\n\t\tvar newState = {};\n\n\t\tif (isForcedToRenew) newState.isForcedToUpdate = true;\n\n\t\tnewState.shouldUseBottomEdgeOfLowerBoundaryRefElement = !!shouldUseBottomEdgeOfLowerBoundaryRefElement;\n\n\t\trequestLayoutUpdate.call(thisInstance, newState);\n\t}\n\n\n\n\tfunction _renewContentHeight(isForcedToRenew) {\n\t\tvar newState = {\n\t\t\tblockHeight: this.elements.hangingBlock.offsetHeight\n\t\t};\n\n\t\tif (isForcedToRenew) newState.isForcedToUpdate = true;\n\n\t\trequestLayoutUpdate.call(this, newState);\n\t}\n\n\tfunction _renewContentTopToRootTopInFreeLayout(isForcedToRenew) {\n\t\tvar newState = {},\n\t\t\tpName = 'contentTopToRootTopInFreeLayout'\n\t\t;\n\n\t\tif (isForcedToRenew) newState.isForcedToUpdate = true;\n\n\t\tnewState[pName] = this.elements.hangingBlock.offsetTop;\n\n\t\trequestLayoutUpdate.call(this, newState);\n\t}\n\n\tfunction _renewContentTopToPageTopInFreeLayout(isForcedToRenewWithoutWaitingForLayoutToSwitch) {\n\t\tvar thisInstance = this,\n\t\t\tprivateState = _privateDataOf(thisInstance).state,\n\t\t\tshouldDoRenew = true,\n\t\t\tfunctionForSwitchingToCorrectLayout,\n\t\t\tforcedImmediateSwitchingWasSkipped = true,\n\t\t\tpNameNextTimeRenewFreeLayout = 'shouldRenewFreeLayoutInfoNextTimeEnteringFreeLayout'\n\t\t\t;\n\n\t\tif (!privateState.layouts.isFreeLayout) {\n\t\t\tif (isForcedToRenewWithoutWaitingForLayoutToSwitch) {\n\t\t\t\tprivateState[pNameNextTimeRenewFreeLayout] = false;\n\t\t\t\tfunctionForSwitchingToCorrectLayout = thisInstance.state.methodForSwitchingToCurrentLayout;\n\t\t\t\tforcedImmediateSwitchingWasSkipped = ____switchLayoutToFree(\n\t\t\t\t\tthisInstance,\n\t\t\t\t\tisForcedToRenewWithoutWaitingForLayoutToSwitch,\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// console.debug('Action holded for a later time.');\n\t\t\t\tshouldDoRenew = false;\n\t\t\t\tprivateState[pNameNextTimeRenewFreeLayout] = true;\n\t\t\t}\n\t\t}\n\n\t\tif (shouldDoRenew) {\n\t\t\t__doRenewContentTopToPageTopInFreeLayout(thisInstance, isForcedToRenewWithoutWaitingForLayoutToSwitch);\n\t\t}\n\n\t\tif (\n\t\t\t!forcedImmediateSwitchingWasSkipped\n\t\t\t&& typeof functionForSwitchingToCorrectLayout === 'function'\n\t\t) {\n\t\t\t// console.debug('Restore layout after switching to free layout temporarily.');\n\t\t\tfunctionForSwitchingToCorrectLayout(thisInstance);\n\t\t}\n\t}\n\n\tfunction __doRenewContentTopToPageTopInFreeLayout(thisInstance, isForcedToRenew) {\n\t\tvar contentClientRect = thisInstance.elements.hangingBlock.getBoundingClientRect();\n\n\t\tif (contentClientRect.width === 0 && contentClientRect.height === 0) {\n\t\t\tconsole.warn(\n\t\t\t\t'\\n\\t Cannot evaluate hangingBlockElement\\'s \"boundingClientRect\"!',\n\t\t\t\t'\\n\\t The chief content elment might not be visible at the moment.'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\n\t\tvar newState = {};\n\n\t\tif (isForcedToRenew) newState.isForcedToUpdate = true;\n\n\t\tnewState.contentTopToPageTopInFreeLayout = contentClientRect.top + window.scrollY;\n\t\t// console.log('*** newState: content top to page:', newState.contentTopToPageTopInFreeLayout, '***');\n\n\t\trequestLayoutUpdate.call(thisInstance, newState);\n\t}\n\n\n\n\n\n\tfunction requestLayoutUpdate(newStateOrFunctionToGenerateNewStateOrABoolean) {\n\t\tvar thisInstance = this,\n\t\t\tstatesQueue = _privateDataOf(thisInstance).updatingStatesQueue\n\t\t;\n\n\n\t\t// At presnet, no more than one state is allowed in queue.\n\t\t// So whenever there exists one item in the array,\n\t\t// we simply use it, instead of create a new one.\n\t\tvar shouldCreateNewStateObject = !statesQueue[statesQueue.length-1];\n\t\tif (shouldCreateNewStateObject) {\n\t\t\tstatesQueue.push({});\n\t\t}\n\n\n\t\tvar stateToUpdate = statesQueue[statesQueue.length-1];\n\n\t\tif (typeof newStateOrFunctionToGenerateNewStateOrABoolean === 'function') {\n\t\t\tnewStateOrFunctionToGenerateNewStateOrABoolean.call(thisInstance, stateToUpdate);\n\t\t} else if (\n\t\t\ttypeof newStateOrFunctionToGenerateNewStateOrABoolean === 'object' &&\n\t\t\t!Array.isArray(newStateOrFunctionToGenerateNewStateOrABoolean)\n\t\t) {\n\t\t\t// console.debug('merging states in the queue...');\n\t\t\tmergeBIntoA(stateToUpdate, newStateOrFunctionToGenerateNewStateOrABoolean);\n\t\t} else {\n\t\t\tstateToUpdate.isForcedToUpdate = stateToUpdate.isForcedToUpdate ||\n\t\t\t\t(typeof newStateOrFunctionToGenerateNewStateOrABoolean === 'undefined') ||\n\t\t\t\t!!newStateOrFunctionToGenerateNewStateOrABoolean\n\t\t\t;\n\t\t}\n\t}\n\n\t// function _processAllupdatingStatesQueue(thisInstance) {\n\t// \twhile (_privateDataOf(this).updatingStatesQueue.length > 0) {\n\t// \t\t__processOneQueuedStateForAnUpdateOfLayoutInQueue(thisInstance);\n\t// \t}\n\t// \t___updateAllDerivedStatesAccordingToNewState();\n\t// }\n\n\tfunction __processOneQueuedStateForAnUpdateOfLayoutInQueue(thisInstance) {\n\t\tvar privateData = _privateDataOf(thisInstance);\n\n\t\tvar newState = privateData.updatingStatesQueue.shift();\n\n\t\t___detectChangesBetweenStates(thisInstance, thisInstance.state, newState);\n\n\n\t\t// console.debug(\n\t\t// \t'******** newState to update ********',\n\t\t// \t'\\n'+'updateLayout();', \n\t\t// \t'\\n'+JSON.stringify(newState),\n\t\t// \t'\\n\\n\\n'\n\t\t// );\n\n\t\treturn newState;\n\t}\n\n\n\n\n\tfunction _mergeNewStateIntoModuleCurrentState(thisInstance, newState) {\n\t\tmergeBIntoA(thisInstance.state, newState);\n\t}\n\n\tfunction ___detectChangesBetweenStates(thisInstance, state1, state2) {\n\t\t____detectChangesOnAllPropertiesAndRemoveThoseWontChangeFromState2(thisInstance, state1, state2);\n\t\t____processState2AccordingToPreservedProperties(thisInstance, state2);\n\t}\n\n\tfunction ____detectChangesOnAllPropertiesAndRemoveThoseWontChangeFromState2(thisInstance, state1, state2) {\n\t\tObject.keys(thisInstance.state).forEach(function (pName) {\n\t\t\tvar thisPropertyWillChange = _____detectChangeForAProperty(pName, state1, state2);\n\t\t\tif (thisPropertyWillChange) {\n\t\t\t\t_privateDataOf(thisInstance).state.somethingChanged = true;\n\t\t\t} else {\n\t\t\t\tdelete state2[pName];\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction _____detectChangeForAProperty(pName, object1, object2) {\n\t\tvar changed = false,\n\t\t\tv1 = object1[pName],\n\t\t\tv2 = object2[pName]\n\t\t\t;\n\n\t\tif (v2 === undefined || v2 === null) {\n\t\t\treturn false;\n\t\t} else if (v1 === undefined || v1 === null) {\n\t\t\tchanged = true;\n\t\t} else if (v1 !== v2) {\n\t\t\tchanged = !(isNaN(v1) && isNaN(v2));\n\t\t}\n\n\t\tif (changed) {\n\t\t\tconsole.debug(\n\t\t\t\t'\"'+pName+'\" will change\\n',\n\t\t\t\tindentAlignsToLogNameOfClass+'from', v1, 'into', v2\n\t\t\t);\n\t\t}\n\n\t\treturn changed;\n\t}\n\n\tfunction ____processState2AccordingToPreservedProperties(thisInstance, state2) {\n\t\t// At present, only the \"reason\" property\n\t\t// which might be introduced by enabling/disabling hanging behaviour\n\t\t// should be processed here\n\n\n\n\t\tif (!_privateDataOf(thisInstance).state.somethingChanged) return;\n\n\n\n\t\tvar pName1, logString1, logString2, logString3\n\t\t\t// , rootElement = thisInstance.elements.root\n\t\t;\n\n\n\t\tif (typeof state2.shouldEnable === 'boolean') {\n\t\t\tpName1 = 'reason';\n\n\t\t\tvar willEnableHanging = state2.shouldEnable;\n\n\t\t\tlogString1 = willEnableHanging ? 'Enabling' : state2.shouldDestroyAfterDisabled ? 'DESTORYING' : 'DISABLING';\n\t\t\tlogString2 = 'behaviour...\\n';\n\t\t\tlogString3 = state2[pName1]\n\t\t\t\t// + '\\n module rootElement:'\n\t\t\t;\n\n\t\t\tlogString3 = indentAlignsToLogNameOfClass.slice('Reason: '.length)\n\t\t\t\t+ 'Reason: '\n\t\t\t\t+ logString3.replace(/\\n/g, '\\n '+indentAlignsToLogNameOfClass);\n\n\t\t\tif (willEnableHanging) {\n\t\t\t\tconsole.info(logString1, logString2, logString3\n\t\t\t\t\t// , rootElement\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// In Google Chrome, \"console.warn\" now has a prefixing triangle to show calling stacks,\n\t\t\t\t// so we nee one more space.\n\t\t\t\tconsole.warn(logString1, logString2, ' ', logString3\n\t\t\t\t\t// , rootElement\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\n\t// You can also name this function as something like \"flushQueuedTasks\".\n\tfunction updateLayout() {\n\t\tvar thisInstance = this,\n\t\t\tprivateData = _privateDataOf(thisInstance),\n\t\t\tpublicState = thisInstance.state,\n\t\t\tstatesQueue = privateData.updatingStatesQueue\n\t\t\t;\n\n\n\t\t// if there are zero tasks in queue, simply do nothing\n\t\tif (statesQueue.length < 1) {\n\t\t\t// console.debug('No queued states at all. Nothing to do.');\n\t\t\treturn;\n\t\t}\n\n\n\n\t\t// There are two possible policies at least.\n\t\t// whenever get a chance to run queued tasks, run them all;\n\t\t// or, whenever get a chance to run a task, run the oldest one.\n\t\t// BUT,\n\t\t// since at present I allow no more than one task,\n\t\t// the two policies mentioned above turn to be the same finally.\n\n\t\t// var newState = _processAllupdatingStatesQueue(thisInstance); // policy 1\n\t\tvar newState = __processOneQueuedStateForAnUpdateOfLayoutInQueue(thisInstance); // policy 2\n\n\n\n\n\t\tvar isForcedToUpdate = newState.isForcedToUpdate;\n\t\tdelete newState.isForcedToUpdate;\n\t\t// console.log('updateLayout(): changes?', privateData.state.somethingChanged, '\\t forced to?', isForcedToUpdate);\n\n\n\t\tif (privateData.state.somethingChanged || isForcedToUpdate) {\n\t\t\t// Should always merge, because extra properties like \"reason\" should be carried\n\t\t\t_mergeNewStateIntoModuleCurrentState(thisInstance, newState);\n\n\t\t\t// Now, do the work\n\t\t\t_doUpdateLayout(thisInstance, isForcedToUpdate);\n\t\t}\n\n\n\n\t\tif (typeof newState.shouldEnable === 'boolean') {\n\t\t\t// reason should be available for onEnabled/onDisabled events\n\t\t\t_onEnabledOrDisabled(thisInstance, newState.shouldEnable);\n\n\t\t\t// now delete the old reason\n\t\t\tdelete publicState.reason;\n\t\t}\n\t}\n\n\tfunction _doUpdateLayout(thisInstance, isForcedToUpdate) {\n\t\tvar privateState = _privateDataOf(thisInstance).state,\n\t\t\tpublicState = thisInstance.state,\n\t\t\telements = thisInstance.elements\n\t\t\t;\n\n\t\t__evaluateHangingBoundries(thisInstance);\n\n\n\t\tvar hangingTopOffset = publicState.contentTopToWindowTopInHangingLayouts,\n            topBoundaryToPageTop = window.scrollY + hangingTopOffset,\n            boundriesDistance = publicState.hangingLowerBoundaryToPageTop - publicState.contentTopToPageTopInFreeLayout,\n            requiredRoomInY = publicState.blockHeight + publicState.contentBottomToLowerBoundaryInHangingLayouts,\n            availableRoomInY = privateState.hangingLowerBoundaryToWindowTop - hangingTopOffset,\n\n\n\t\t    // Might need compensation to some margins but not implemented yet\n\t\t    blockRootHeightWhenPinned = publicState.blockHeight;\n\n\n\t\tvar thereIsNoEnoughRoomForThisBlockToHang =\n\t\t\twindow.innerHeight < requiredRoomInY ||\n\t\t\t(\n\t\t\t\t// NaN means lower boundary doesn't available at all,\n\t\t\t\t// so there is always enough room\n\t\t\t\t!isNaN(boundriesDistance) &&\n\n\t\t\t\tboundriesDistance < requiredRoomInY\n\t\t\t)\n\t\t;\n\n\n\n\t\t// console.debug(\n\t\t// \t'\\n\\t someting changed?', privateState.somethingChanged,\n\n\t\t// \t'\\n to pin to top:',\n\t\t// \t'\\n\\t window scroll y:', topBoundaryToPageTop,\n\t\t// \t'\\n\\t free layout top:', publicState.contentTopToPageTopInFreeLayout,\n\t\t// \t'\\n\\t window scroll y <= free layout top?', topBoundaryToPageTop <= publicState.contentTopToPageTopInFreeLayout,\n\n\t\t// \t'\\n to pin to bottom:',\n\t\t// \t'\\n\\t lower boundary y:', privateState.hangingLowerBoundaryToWindowTop,\n\t\t// \t'\\n\\t available y:', availableRoomInY,\n\t\t// \t'\\n\\t required room y:', requiredRoomInY,\n\t\t// \t'\\n\\t available y <= required room y?', availableRoomInY < requiredRoomInY\n\t\t// );\n\n\t\tif (!publicState.shouldEnable ||\n\t\t\tthereIsNoEnoughRoomForThisBlockToHang ||\n\t\t\ttopBoundaryToPageTop <= publicState.contentTopToPageTopInFreeLayout\n\t\t) {\n\t\t\t____switchLayoutToFree(thisInstance, isForcedToUpdate);\n\t\t} else if (availableRoomInY <= requiredRoomInY) {\n\t\t\t____switchLayoutToContentPinningAboveLowerBoundary(\n\t\t\t\tthisInstance,\n\t\t\t\tisForcedToUpdate,\n\t\t\t\tblockRootHeightWhenPinned,\n\t\t\t\tboundriesDistance - requiredRoomInY + elements.root.clientTop + publicState.contentTopToRootTopInFreeLayout\n\t\t\t);\n\t\t} else {\n\t\t\t____switchLayoutToContentHangingToWindowTop(\n\t\t\t\tthisInstance,\n\t\t\t\tisForcedToUpdate,\n\t\t\t\tblockRootHeightWhenPinned,\n\t\t\t\tpublicState.contentTopToWindowTopInHangingLayouts\n\t\t\t);\n\t\t}\n\n\n\t\tprivateState.somethingChanged = false;\n\t\tdelete publicState.methodForSwitchingToCurrentLayout;\n\t}\n\n\tfunction __evaluateHangingBoundries(thisInstance) {\n\t\t// this function not only updates some state values,\n\t\t// but also returns a newState object for other function to utilize\n\n\t\tvar publicState = thisInstance.state,\n\t\t\tpName = 'hangingLowerBoundaryToPageTop',\n            refElement = publicState.lowerBoundaryRefElement,\n            refElementClientRect,\n\t\t\trefNewYToWindowTop = NaN,\n\t\t\trefNewYToPageTop = NaN\n\t\t\t;\n\n        if (refElement instanceof Node) {\n            refElementClientRect = refElement.getBoundingClientRect();\n            if (refElementClientRect.width === 0 && refElementClientRect.height === 0) {\n                console.warn('Reference element for deciding hanging lower boundary is invisible at this moment.');\n            } else {\n                refNewYToWindowTop = refElementClientRect[publicState.shouldUseBottomEdgeOfLowerBoundaryRefElement ? 'bottom' : 'top'];\n                refNewYToPageTop = refNewYToWindowTop + window.scrollY;\n            }\n        } else {\n\t\t\tconsole.debug('Reference element for deciding hanging lower boundary is not provided.');\n            // do nothing, keeping NaN values\n        }\n\n\n\t\t// values below might be NaN, as long as the refElement is not available any more or is hidden\n\t\t_privateDataOf(thisInstance).state.hangingLowerBoundaryToWindowTop = refNewYToWindowTop;\n\t\tpublicState[pName] = refNewYToPageTop;\n\t}\n\n\tfunction ____switchLayoutToFree(thisInstance, isForcedToUpdate, isForcedByAForcedRenew) {\n\t\tvar privateState = _privateDataOf(thisInstance).state,\n\t\t\tlayoutBeforeSwitchingWasExactlyFreeLayout = privateState.layouts.isFreeLayout // cache old state\n\t\t;\n\n\t\tvar switchingWasSkipped =\n\t\t_____commonActionsWhenSwitchingLayout(thisInstance, {\n\t\t\tmethodForSwitchingToCurrentLayout: ____switchLayoutToFree, // of cause, should be itself\n\t\t\tisForcedToUpdate: isForcedToUpdate,\n\t\t\tpNameOfLayoutMark: 'isFreeLayout',\n\t\t\tpNameOfCssClass: isForcedByAForcedRenew ? 'layoutFreeTemporary' : 'layoutFree',\n\t\t\trootElHeight: '', // thisInstance.state.blockHeight + 'px'\n\t\t\tcontentElTop: ''\n\n\t\t\t// , logStringWhenActuallySwitching: '*** switching content layout back to free layout...'\n\t\t\t// , shouldDebug: true\n\t\t});\n\n\n\n\t\tif (!switchingWasSkipped) {\n\t\t\t// if (isForcedByAForcedRenew) {\n\t\t\t// \tconsole.debug('Forced to switch to free layout temporarily.');\t\t\t\t\n\t\t\t// }\n\n\t\t\tvar shouldAlwaysRenewFreeLayoutInfo = thisInstance.options.shouldAlwaysRenewFreeLayoutInfo,\n\t\t\t\tpNameNextTimeRenewFreeLayout = 'shouldRenewFreeLayoutInfoNextTimeEnteringFreeLayout' // for better minification\n\t\t\t;\n\n\t\t\tif (\n\t\t\t\t(shouldAlwaysRenewFreeLayoutInfo || privateState[pNameNextTimeRenewFreeLayout])\n\t\t\t\t&& !layoutBeforeSwitchingWasExactlyFreeLayout\n\t\t\t\t// && !isForcedByAForcedRenew\n\t\t\t) {\n\t\t\t\t// For the invocation below,\n\t\t\t\t// as we can see the value of the \"forcedToDoSo\" argument is not <true>,\n\t\t\t\t// so basically if there are no changes happened at all,\n\t\t\t\t// the _doUpdateLayout() will not be called,\n\t\t\t\t// thus the infinite looping invocation will not occur.\n\t\t\t\t\n\t\t\t\t// Note that if this function is invoked for switching layout temporarily,\n\t\t\t\t// this means the invokation was taken by the renewStateAndThenUpdate itself\n\t\t\t\t// thus we should avoid infinite looping.\n\n\t\t\t\t// console.debug('Returned to free layout. An opportunity to renew all related info.');\n\t\t\t\trenewStateAndThenUpdate.call(thisInstance);\n\t\t\t}\n\n\t\t\tprivateState[pNameNextTimeRenewFreeLayout] = false;\n\t\t}\n\n\n\t\treturn switchingWasSkipped;\n\t}\n\n\tfunction ____switchLayoutToContentHangingToWindowTop(thisInstance, isForcedToUpdate, blockRootHeightWhenPinned, blockContentTopWhenPinned) {\n\t\t// var switchingWasSkipped =\n\t\treturn _____commonActionsWhenSwitchingLayout(thisInstance, {\n\t\t\tmethodForSwitchingToCurrentLayout: ____switchLayoutToContentHangingToWindowTop, // of cause, should be itself\n\t\t\tisForcedToUpdate: isForcedToUpdate,\n\t\t\tpNameOfLayoutMark: 'isPinnedToWindowTop',\n\t\t\tpNameOfCssClass: 'layoutPinToWindowTop',\n\t\t\trootElHeight: blockRootHeightWhenPinned + 'px',\n\t\t\tcontentElTop: blockContentTopWhenPinned + 'px'\n\n\t\t\t// , logStringWhenActuallySwitching: '*** Hanging content to window top...'\n\t\t\t// , shouldDebug: true\n\t\t});\n\t}\n\n\tfunction ____switchLayoutToContentPinningAboveLowerBoundary(thisInstance, isForcedToUpdate, blockRootHeightWhenPinned, contentElNewTop) {\n\t\t// var switchingWasSkipped =\n\t\treturn _____commonActionsWhenSwitchingLayout(thisInstance, {\n\t\t\tmethodForSwitchingToCurrentLayout: ____switchLayoutToContentPinningAboveLowerBoundary, // of cause, should be itself\n\t\t\tisForcedToUpdate: isForcedToUpdate,\n\t\t\tpNameOfLayoutMark: 'isPinnerToParentBottom',\n\t\t\tpNameOfCssClass: 'layoutPinToParentBottom',\n\t\t\trootElHeight: blockRootHeightWhenPinned + 'px',\n\t\t\tcontentElTop: contentElNewTop + 'px'\n\n\t\t\t// , logStringWhenActuallySwitching: '*** Pinning content to follow lower boundary...'\n\t\t\t// , shouldDebug: true\n\t\t});\n\t}\n\n\tfunction _____commonActionsWhenSwitchingLayout(thisInstance, options) {\n\t\t// Returns true:  switching skipped;\n\t\t// Returns false: switching proceeded.\n\n\t\t// options = options || {};\n\t\tvar privateState = _privateDataOf(thisInstance).state,\n\t\t\tpublicState = thisInstance.state,\n\t\t\telements = thisInstance.elements,\n\t\t\tpNameOfLayoutMark = options.pNameOfLayoutMark,\n\t\t\tpNameSaveMethod = 'methodForSwitchingToCurrentLayout'\n\t\t\t, logInfo = options.logStringWhenActuallySwitching\n\t\t\t;\n\n\t\t// if (options.shouldDebug) {\n\t\t\t// console.debug(\n\t\t\t// \t!privateState.layouts.[pNameOfLayoutMark] ? '\\n\\t'+pNameOfLayoutMark + ' ' + privateState.layouts.[pNameOfLayoutMark] : '',\n\t\t\t// \toptions.isForcedToUpdate ? '\\n\\tbecause is forced to? ' + options.isForcedToUpdate : '',\n\t\t\t// \tprivateState.somethingChanged ? '\\n\\t  because something changed? '+ privateState.somethingChanged : ''\n\t\t\t// );\n\t\t// }\n\t\tif (privateState.layouts[pNameOfLayoutMark] && !privateState.somethingChanged && !options.isForcedToUpdate) return true;\n\t\toptions.shouldDebug && logInfo && console.info(logInfo);\n\n\t\tpublicState[pNameSaveMethod] = options[pNameSaveMethod];\n\n\t\t______soloLayoutStateTo(thisInstance, pNameOfLayoutMark);\n\t\t______soloCssClassTo(thisInstance, options.pNameOfCssClass);\n\n\t\telements.hangingBlock.style.top = options.contentElTop;\n\t\telements.root.style.height = options.rootElHeight;\n\n\t\treturn false;\n\t}\n\n\tfunction ______soloLayoutStateTo(thisInstance, propertyKeyOfLayoutState) {\n\t\tvar layoutStates = _privateDataOf(thisInstance).state.layouts;\n\t\tObject.keys(layoutStates).forEach(function (key) {\n\t\t\tlayoutStates[key] = propertyKeyOfLayoutState === key;\n\t\t});\n\t}\n\n\tfunction ______soloCssClassTo(thisInstance, propertyKeyOfCssClassToApply) {\n\t\tvar hangingBlockClassList = thisInstance.elements.hangingBlock.classList,\n\t\t\tcssClassNameOptions = thisInstance.options.cssClassName\n\t\t;\n\n\t\tfor (var key in cssClassNameOptions) {\n\t\t\tvar cssClassName = cssClassNameOptions[key];\n\t\t\tif (key === propertyKeyOfCssClassToApply) {\n\t\t\t\t// console.debug('-----<<<< add css:', cssClassName);\n\t\t\t\tcssClassName && hangingBlockClassList.add   (cssClassName);\n\t\t\t} else {\n\t\t\t\t// console.debug('-----<<<< remove css:', cssClassName);\n\t\t\t\tcssClassName && hangingBlockClassList.remove(cssClassName);\n\t\t\t}\n\t\t}\n\t}\n});\n"]}